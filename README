THE PVSHM FILE SYSTEM

Warning

Pvshm is a very experimental Linux kernel module. And it breaks several
conventions. Don't use it on production machines. It can crash your system!

Rationale

The pvshm module defines an overlay file system for the Linux kernel that sits
between applications and an underlying file system. The pvshm module implements
address space operations on its files as read and write operations on
corresponding backing files in the underlying file system. Pvshm is designed to
provide file memory mapping capability for file systems that do not natively
support memory mapping. In particular, we wrote pvshm to allow us to memory map
files on a pvfs2 file system without modifying pvfs2 itself.
 
Pvshm does not enforce cache consistency between processes accessing the same
file. Instead, we leave the management of cache consistency up to the
applications by providing user space functions for cache updates after write
operations (a traditional msync function), and before read operations (a kind
of reverse msync).


Design

Loading the pvshm.ko module enables support for the file system. Pvshm
does not use a backing device and is mounted similarly to ramfs and tmpfs
file systems.

Symbolic links are a special operation for pvshm. One uses a symbolic link to
set up a 'shadow' file in pvshm. Address space operations on the link are
implemented as read or write operations on the backing file. We chose this
unconvention to make pvshm easy to use with existing tools. When a link
is created, the backing file is opened for reading and writing by the module.

Deleting a symbolic link closes the open file descriptor to the backing file
and de-allocates data structures used by pvshm internally.  Although memory
mapping is the main design objective, basic read and write file operations are
supported for convenience.  Pvshm now supports multiple simultaneous writers
with byte-level granularity, but a memory overhead is incurred. See the NOTES
for more detailed information.


Cache consistency

Pvshm does not automatically enforce cache consistency between multiple
processes mapping the same file. Instead, pvshm leaves that to applications
by providing functions for managing the page cache.

The standard msync call is implemented. When called by a process, mysnc causes
cached pages that have been flagged as changed to be written back to the
backing file.

Pvshm provides a function to explicitly populate the page cache with data from
the backing file, replacing any data already in the cache (sort of a reverse
msync). This function is implemented using a variation of the standard read
function (using read allows us to provide this functionality to applications
through standard and universally available system libraries). Calling the
standard read function results in a pass-through read operation to the
corresponding backing file. However, if the buffer argument to the read
function is NULL, there will be no pass-through read and instead the pages in
the page cache range associated with the extent of the read call will be
updated with data from the backing file. Consider the following example:

int fd = open("/path/to/pvshm/file", O_RDWR);
size_t count = 555;
void *buf = (void *)malloc(count);
read(fd, buf, count);

The above example will read 555 bytes as expected from the current file
position in the file. However, this next example will simply update the page
cache with data from the backing file covering the requested 555 bytes
(in particular, the first page will be updated):

size_t count = 555;
read(fd, NULL, count);


Example

# This example creats a one megabyte backing file on the current file system,
# installs the pvshm module and creates a shadow file suitable for memory
# mapping in the pvshm file system.

dd if=/dev/zero of=backing_file bs=1M count=1
insmod pvshm.ko
mount -t pvshm none /mnt
ln -s backing_file /mnt

# (you can now memory map /mnt/backing_file)

umount /mnt
rmmod pvshm
